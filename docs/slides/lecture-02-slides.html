<!DOCTYPE html>
<html lang="en"><head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/tabby.min.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.7.31">

  <meta name="author" content="Joseph Rudoler">
  <meta name="dcterms.date" content="2025-07-14">
  <title>Understanding Uncertainty – Lecture 02: Probability and Random Variables</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; font-weight: bold; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../site_libs/revealjs/dist/theme/quarto-f563837468303362081e247dddd440d0.css">
  <link href="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-chalkboard/font-awesome/css/all.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-chalkboard/style.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
  
  <script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">Lecture 02: Probability and Random Variables</h1>

<div class="quarto-title-authors">
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Joseph Rudoler 
</div>
</div>
</div>

  <p class="date">2025-07-14</p>
</section>
<section class="slide level2">

<div class="hidden">
<p><span class="math display">\[
\renewcommand{\P}{\mathbb{P}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\Var}{\mathbb{V}\text{ar}}
\newcommand{\Cov}{\mathbb{C}\text{ov}}
\]</span></p>
</div>
</section>
<section id="probability" class="slide level2">
<h2>Probability</h2>
<p>Most of you are probably familiar with the basic intuition of <strong>probability</strong>: essentially it measures how likely an event is to occur.</p>
<div class="fragment">
<p>In mathematical terms, the probability <span class="math inline">\(\P\)</span> of an event <span class="math inline">\(A\)</span> is defined as:</p>
<p><span class="math display">\[\begin{align*}
\P(A) &amp;= \frac{\text{ \# of outcomes where } A \text{ occurs}}{\text{ total \# of outcomes}} \\
\end{align*}\]</span></p>
</div>
<div class="fragment">
<p>By definition this quantity:</p>
<ul>
<li class="fragment">cannot be negative (<span class="math inline">\(\P(A) = 0\)</span> means <span class="math inline">\(A\)</span> never occurs), and</li>
<li class="fragment">it must be less than or equal to 1 (<span class="math inline">\(\P(A) = 1\)</span> means <span class="math inline">\(A\)</span> always occurs).</li>
</ul>
</div>
</section>
<section id="example-coin-flip" class="slide level2">
<h2>Example: Coin Flip</h2>
<p>The classical example of probability is flipping a coin. When you flip a fair coin, there are two possible outcomes: heads (<span class="math inline">\(H\)</span>) and tails (<span class="math inline">\(T\)</span>).</p>
<p>If we let <span class="math inline">\(A\)</span> be the event that the coin lands on heads, then we can compute the probability of <span class="math inline">\(A\)</span> as follows:</p>
<p><span class="math display">\[\begin{align*}
\P(\text{H}) &amp;= \frac{\text{ \# of heads}}{\text{ total \# of outcomes}} \\
      &amp;= \frac{1}{2} \\
\end{align*}\]</span></p>
<p>This matches our intuition that a fair coin has a 50% chance of landing on heads.</p>
</section>
<section id="properties-of-probability-sum-to-1" class="slide level2">
<h2>Properties of Probability: Sum to 1</h2>
<p>An important property of probabilities is that the sum of the probabilities of all possible outcomes must equal 1. This is like say “there’s a 100% chance that <em>something</em> will happen”.</p>
<div class="fragment">
<p>In our coin flip example, we have two possible outcomes: heads and tails. If the coin flip is not heads, it must be tails. In other words, the events <span class="math inline">\(H\)</span> and <span class="math inline">\(T\)</span> cover 100% of the possible outcomes. So we can write: <span class="math display">\[\begin{align*}
\P(H) + \P(T) &amp;= 1 \\
\frac{1}{2} + \frac{1}{2} &amp;= 1
\end{align*}\]</span></p>
</div>
<div class="fragment">
<p>When we know the events we are interested in make up all of the possible outcomes, we can use this property to compute probabilities.</p>
</div>
<div class="fragment">
<p>For example, for any event <span class="math inline">\(A\)</span>, the event either happens or it doesn’t. So we can compute the probability of the event not occurring as: <span class="math display">\[\begin{align*}
\P(\text{not}~ A) &amp;= 1 - \P(A)
\end{align*}\]</span></p>
</div>
</section>
<section id="probability-of-multiple-events" class="slide level2">
<h2>Probability of multiple events</h2>
<p>But what if we flip the coin twice?</p>
<p>Now there are four possible outcomes:</p>
<ul>
<li class="fragment"><span class="math inline">\(HH\)</span></li>
<li class="fragment"><span class="math inline">\(HT\)</span></li>
<li class="fragment"><span class="math inline">\(TH\)</span></li>
<li class="fragment"><span class="math inline">\(TT\)</span></li>
</ul>
<div class="fragment">
<p>If we let <span class="math inline">\(B\)</span> be the event that at least one coin lands on heads, we can compute the probability of <span class="math inline">\(B\)</span> as follows:</p>
</div>
<div class="fragment">
<p><span class="math display">\[\begin{align*}
\P(B) &amp;= \frac{\text{ \# of outcomes with at least one head}}{\text{ total \# of outcomes}} \\
      &amp;= \frac{|\{HH, HT, TH\}|}{|\{HH, HT, TH, TT\}|} \\
      &amp;= \frac{3}{4} \\
\end{align*}\]</span></p>
</div>
</section>
<section id="probability-of-multiple-events-and-vs-or" class="slide level2">
<h2>Probability of multiple events: AND vs OR</h2>
<p>What is the probability of getting heads on the first flip AND the second flip (i.e., the event <span class="math inline">\(C = \{HH\}\)</span>)?</p>
<ul>
<li class="fragment">There is only one outcome where both flips are heads</li>
<li class="fragment">Still four total outcomes</li>
<li class="fragment"><span class="math inline">\(\P(C) = \P (H_1 ~\text{and}~ H_2) = \frac{1}{4}\)</span>.</li>
</ul>
<div class="fragment">
<p>What about the probability of getting heads on the first flip OR the second flip?</p>
</div>
<div class="fragment">
<p>This is actually the same event as <span class="math inline">\(B\)</span> before (at least 1 heads), so we can use the same calculation:</p>
<p><span class="math inline">\(\P(B) = \P(H_1 ~\text{or}~ H_2) = \frac{3}{4}\)</span>.</p>
</div>
</section>
<section id="set-notation-and-or" class="slide level2">
<h2>Set notation (AND / OR)</h2>
<p>In the above, we used <span class="math inline">\(H_1\)</span> and <span class="math inline">\(H_2\)</span> to denote heads on the first and second flips, respectively.</p>
<p>The notation <span class="math inline">\(H_1 ~\text{and}~ H_2\)</span> means both flips are heads, while <span class="math inline">\(H_1 ~\text{or}~ H_2\)</span> means at least one flip is heads.</p>
<p>In probability theory, we often use the symbols <span class="math inline">\(\cap\)</span> and <span class="math inline">\(\cup\)</span> to denote “and” and “or” respectively.</p>
<p>So we could also write <span class="math inline">\(\P(H_1 \cap H_2)\)</span> for the probability of both flips being heads, and <span class="math inline">\(\P(H_1 \cup H_2)\)</span> for the probability of at least one flip being heads.</p>
<p>Technically, this is set notation where <span class="math inline">\(\cap\)</span> means intersection (the event where both <span class="math inline">\(H_1\)</span> and <span class="math inline">\(H_2\)</span> occur), while <span class="math inline">\(\cup\)</span> means union (the event where either <span class="math inline">\(H_1\)</span> or <span class="math inline">\(H_2\)</span> occurs).</p>
</section>
<section id="rules-for-multiple-events" class="slide level2">
<h2>Rules for multiple events</h2>
<p>There are some important rules for calculating probabilities of multiple events. In particular, if you have two events <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, the following rules hold:</p>
<ul>
<li class="fragment"><p><strong>Addition rule</strong>: For any two events <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, the probability of either <span class="math inline">\(A\)</span> or <span class="math inline">\(B\)</span> occurring is given by: <span class="math display">\[
\P(A \cup B) = \P(A) + \P(B) - \P(A \cap B)
\]</span> This last term, <span class="math inline">\(\P(A \cap B)\)</span>, is necessary to avoid double counting the outcomes where both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> occur.</p>
<p>Note that if <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are mutually exclusive (i.e., they cannot both occur at the same time), then <span class="math inline">\(\P(A \cap B) = 0\)</span>, and the formula simplifies to: <span class="math display">\[  \P(A \cup B) = \P(A) + \P(B)\]</span></p></li>
</ul>
</section>
<section id="rules-for-multiple-events-1" class="slide level2">
<h2>Rules for multiple events</h2>
<div title="Visualizing sets of events">
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Visualizing sets of events</strong></p>
</div>
<div class="callout-content">
<p>The following image illustrates the addition rule for two events <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> using a Venn diagram. <img data-src="../images/probability-sets-union.jpeg" alt="probability-set"></p>
</div>
</div>
</div>
</div>
</section>
<section id="rules-for-multiple-events-2" class="slide level2">
<h2>Rules for multiple events</h2>
<ul>
<li class="fragment"><strong>Multiplication rule</strong>: For any two events <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, the probability of both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> occurring is given by: <span class="math display">\[\P(A \cap B) = \P(A) \cdot \P(B | A)\]</span> where <span class="math inline">\(\P(B | A)\)</span> is the conditional probability of <span class="math inline">\(B\)</span> given that <span class="math inline">\(A\)</span> has occurred. This means you first consider the outcomes where <span class="math inline">\(A\)</span> occurs, and then look at the probability of <span class="math inline">\(B\)</span> within that subset.</li>
</ul>
<div class="fragment">
<div title="Conditional probability">
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Conditional probability</strong></p>
</div>
<div class="callout-content">
<p>The notation <span class="math inline">\(\P(B | A)\)</span> is read as “the probability of <span class="math inline">\(B\)</span> given <span class="math inline">\(A\)</span>”. It represents the probability of event <span class="math inline">\(B\)</span> occurring under the condition that event <span class="math inline">\(A\)</span> has already occurred.</p>
<p>We make these adjustments in our heads all of the time.</p>
<ul>
<li class="fragment">For example, you might expect that it is more likely I will buy ice cream if it is hot outside. In this case, the event <span class="math inline">\(A\)</span> is “it is hot outside”, and the event <span class="math inline">\(B\)</span> is “I buy ice cream”.</li>
<li class="fragment">The conditional probability <span class="math inline">\(\P(B | A)\)</span> would be higher than <span class="math inline">\(\P(B)\)</span> on a typical day.</li>
</ul>
<p>Let’s think about this in the context of our coin flips. If we know that the first flip is heads (<span class="math inline">\(H_1\)</span>), then only two outcomes are possible (<span class="math inline">\(HH\)</span> and <span class="math inline">\(HT\)</span>) instead of four (<span class="math inline">\(HH\)</span>, <span class="math inline">\(HT\)</span>, <span class="math inline">\(TH\)</span>, <span class="math inline">\(TT\)</span>).</p>
<ul>
<li class="fragment">The conditional probability <span class="math inline">\(\P(H_2 | H_1)\)</span>, which is the probability of the second flip being heads given that the first flip was heads, is: <span class="math display">\[\begin{align*}
\P(H_2 | H_1) &amp;= \frac{\text{ \# of outcomes where } H_2 \text{ occurs and } H_1 \text{ has occurred}}{\text{ total \# of outcomes where } H_1 \text{ has occurred}} \\
&amp;= \frac{|\{HH\}|}{|\{HH, HT\}|} \\
&amp;= \frac{1}{2} \\
\end{align*}\]</span></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="fragment">
<p>The multiplication rule helps us calculate the probability of multiple events happening, as long as we know how one event affects the other (i.e., the conditional probability).</p>
</div>
</section>
<section id="problem-drawing-cards" class="slide level2">
<h2>Problem: Drawing Cards</h2>
<p>Consider a deck of cards (52 cards total, 13 of each suit). I might ask you, “What is the probability of drawing a club on the first draw and a club on the second draw? (Assuming you do not replace the first card.)”</p>
<div id="6aef992a" class="cell" data-execution_count="2">
<div class="cell-output cell-output-display">
<div id="FUBDYjgPuwjl" data-shufflequestions="False" data-shuffleanswers="True" data-preserveresponses="false" data-numquestions="1000000" data-maxwidth="600" style="border-radius: 10px; text-align: left"><style>
#FUBDYjgPuwjl {
   --jq-multiple-choice-bg: #6f78ffff;
   --jq-mc-button-bg: #fafafa;
   --jq-mc-button-border: #e0e0e0e0;
   --jq-mc-button-inset-shadow: #555555;
   --jq-many-choice-bg: #f75c03ff;
   --jq-numeric-bg: #392061ff;
   --jq-numeric-input-bg: #c0c0c0;
   --jq-numeric-input-label: #101010;
   --jq-numeric-input-shadow: #999999;
   --jq-string-bg: #4c1a57;
   --jq-incorrect-color: #c80202;
   --jq-correct-color: #009113;
   --jq-text-color: #fafafa;
}

.Quiz {
    max-width: 600px;
    margin-top: 15px;
    margin-left: auto;
    margin-right: auto;
/*    margin-bottom: 15px;*/
/*    padding-bottom: 4px;*/
    padding-top: 4px;
    line-height: 1.1;
    font-size: 16pt;
    border-radius: inherit;
}

.QuizCode {
    font-size: 14pt;
    margin-top: 10px;
    margin-left: 20px;
    margin-right: 20px;
}

.QuizCode>pre {
    padding: 4px;
}

.Quiz code {
    background-color: lightgray;
    color: black;
}

.Quiz .QuizCode code {
    background-color: inherit;
    color: inherit;
}


.Quiz .MCButton code {
    background-color: inherit;
    color: inherit;
}

.MCButton .QuizCode {
    text-align: left;
}




.Answer {
    border-radius: inherit;
    display: grid;
    grid-gap: 10px;
    grid-template-columns: 1fr 1fr;
    margin: 10px 0;
}

@media only screen and (max-width:480px) {
    .Answer {
        grid-template-columns: 1fr;
    }

}

.Feedback {
    font-size: 16pt;
    text-align: center;
/*    min-height: 2em;*/
}

.Input {
    align: left;
    font-size: 20pt;
}

.Input-text {
    display: block;
    margin: 10px;
    color: inherit;
    width: unset;
    min-width: 140px;
    max-width: 93%;
    field-sizing: content;
    background-color: var(--jq-numeric-input-bg);
    color: var(--jq-text-color);
    padding: 5px;
    padding-left: 10px;
    font-family: inherit;
    font-size: 20px;
    font-weight: inherit;
    line-height: 20pt;
    border: none;
    border-radius: 0.2rem;
    transition: box-shadow 0.1s);
}

.Input-text:focus {
    /*outline: none;*/
    background-color: var(--jq-numeric-input-bg);
    box-shadow: 0.6rem 0.8rem 1.4rem -0.5rem var(--jq-numeric-input-shadow);
}

.MCButton {
    background: var(--jq-mc-button-bg);
    border: 1px solid var(--jq-mc-button-border);
    border-radius: inherit;
    color: #333333;
    padding: 10px;
    font-size: 16px;
    cursor: pointer;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
}

.MCButton p {
    color: inherit;
}

.MultipleChoiceQn {
    padding: 10px;
    background: var(--jq-multiple-choice-bg);
    color: var(--jq-text-color);
    border-radius: inherit;
}

.ManyChoiceQn {
    padding: 10px;
    background: var(--jq-many-choice-bg);
    color: var(--jq-text-color);
    border-radius: inherit;
}

.NumericQn {
    background: var(--jq-numeric-bg);
    border-radius: inherit;
    color: var(--jq-text-color);
    padding: 10px;
}

.NumericQn p {
    color: inherit;
}

.StringQn {
    background: var(--jq-string-bg);
    border-radius: inherit;
    color: var(--jq-text-color);
    padding: 10px;
}

.StringQn p {
    color: inherit;
}


.InpLabel {
    color: var(--jq-numeric-input-label);
    float: left;
    font-size: 15pt;
    line-height: 34px;
    margin-right: 10px;
}

.incorrect {
    color: var(--jq-incorrect-color);
}

.correct {
    color: var(--jq-correct-color);
}

.correctButton {
    /*
    background: var(--jq-correct-color);
   */
    animation: correct-anim 0.6s ease;
    animation-fill-mode: forwards;
    box-shadow: inset 0 0 5px var(--jq-mc-button-inset-shadow);
    color: var(--jq-text-color);
    /*outline: none;*/
}

.incorrectButton {
    animation: incorrect-anim 0.8s ease;
    animation-fill-mode: forwards;
    box-shadow: inset 0 0 5px var(--jq-mc-button-inset-shadow);
    color: var(--jq-text-color);
    /*outline: none;*/
}

@keyframes incorrect-anim {
    100% {
        background-color: var(--jq-incorrect-color);
    }
}

@keyframes correct-anim {
    100% {
        background-color: var(--jq-correct-color);
    }
}
</style>
</div>
<div class="cell-output cell-output-display">
<script type="application/javascript">
var questionsFUBDYjgPuwjl=[{"question": "What is the conditional probability of drawing a club on the second draw given that the first card drawn was a club?", "type": "multiple_choice", "answers": [{"answer": "1/52", "correct": false}, {"answer": "1/4", "correct": false}, {"answer": "12/51", "correct": true}, {"answer": "13/52", "correct": false}]}, {"question": "What is the probability of drawing a club on the first draw and a club on the second draw? (Assuming you do not replace the first card.)", "type": "numeric", "precision": 4, "answers": [{"type": "range", "range": [0.055, 0.062], "correct": true, "feedback": "Correct! The probability is 13/52 * 12/51 = 1/4 * 12/51 = .0588"}, {"type": "default", "feedback": "Incorrect. Consider the multiplication rule!"}]}];

if (typeof Question === 'undefined') {
// Make a random ID
function makeid(length) {
    var result = [];
    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    var charactersLength = characters.length;
    for (var i = 0; i < length; i++) {
        result.push(characters.charAt(Math.floor(Math.random() * charactersLength)));
    }
    return result.join('');
}
// Convert LaTeX delimiters and markdown links to HTML
function jaxify(string) {
    let mystring = string;
    let count = 0, count2 = 0;
    let loc = mystring.search(/([^\\]|^)(\$)/);
    let loc2 = mystring.search(/([^\\]|^)(\$\$)/);
    while (loc >= 0 || loc2 >= 0) {
        if (loc2 >= 0) {
            mystring = mystring.replace(/([^\\]|^)(\$\$)/, count2 % 2 ? '$1\\]' : '$1\\[');
            count2++;
        } else {
            mystring = mystring.replace(/([^\\]|^)(\$)/, count % 2 ? '$1\\)' : '$1\\(');
            count++;
        }
        loc = mystring.search(/([^\\]|^)(\$)/);
        loc2 = mystring.search(/([^\\]|^)(\$\$)/);
    }
    // Replace markdown links
    mystring = mystring.replace(/<http(.*?)>/g, '<a href="http$1" target="_blank" class="Link">http$1</a>');
    mystring = mystring.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" class="Link">$1</a>');
    return mystring;
}

// Base class for question types
class Question {
    static registry = {};
    static register(type, cls) {
        Question.registry[type] = cls;
    }
    static create(qa, id, index, options, rootDiv) {
        const Cls = Question.registry[qa.type];
        if (!Cls) {
            console.error(`No question class registered for type "${qa.type}"`);
            return;
        }
        const q = new Cls(qa, id, index, options, rootDiv);
        q.render();
    }

    constructor(qa, id, index, options, rootDiv) {
        this.qa = qa;
        this.id = id;
        this.index = index;
        this.options = options;
        this.rootDiv = rootDiv;
        // wrapper
        this.wrapper = document.createElement('div');
        this.wrapper.id = `quizWrap${id}`;
        this.wrapper.className = 'Quiz';
        this.wrapper.dataset.qnum = index;
        this.wrapper.style.maxWidth = `${options.maxWidth}px`;
        rootDiv.appendChild(this.wrapper);
        // question container
        this.outerqDiv = document.createElement('div');
        this.outerqDiv.id = `OuterquizQn${id}${index}`;
        this.wrapper.appendChild(this.outerqDiv);
        // question text
        this.qDiv = document.createElement('div');
        this.qDiv.id = `quizQn${id}${index}`;
        if (qa.question) {
            this.qDiv.innerHTML = jaxify(qa.question);
            this.outerqDiv.appendChild(this.qDiv);
        }
        // code block
        if (qa.code) {
            const codeDiv = document.createElement('div');
            codeDiv.id = `code${id}${index}`;
            codeDiv.className = 'QuizCode';
            const pre = document.createElement('pre');
            const codeEl = document.createElement('code');
            codeEl.innerHTML = qa.code;
            pre.appendChild(codeEl);
            codeDiv.appendChild(pre);
            this.outerqDiv.appendChild(codeDiv);
        }
        // answer container
        this.aDiv = document.createElement('div');
        this.aDiv.id = `quizAns${id}${index}`;
        this.aDiv.className = 'Answer';
        this.wrapper.appendChild(this.aDiv);
        // feedback container (append after answers)
        this.fbDiv = document.createElement('div');
        this.fbDiv.id = `fb${id}`;
        this.fbDiv.className = 'Feedback';
        this.fbDiv.dataset.answeredcorrect = 0;
    }

    render() {
        throw new Error('render() not implemented');
    }

    preserveResponse(val) {
        if (!this.options.preserveResponses) return;
        const resp = document.getElementById(`responses${this.rootDiv.id}`);
        if (!resp) return;
        const arr = JSON.parse(resp.dataset.responses);
        arr[this.index] = val;
        resp.dataset.responses = JSON.stringify(arr);
        printResponses(resp);
    }

    typeset(container) {
        if (typeof MathJax !== 'undefined') {
            const v = MathJax.version;
            if (v[0] === '2') {
                MathJax.Hub.Queue(['Typeset', MathJax.Hub]);
            } else {
                MathJax.typeset([container]);
            }
        }
    }
}

// Choose a random subset of an array. Can also be used to shuffle the array
function getRandomSubarray(arr, size) {
    var shuffled = arr.slice(0), i = arr.length, temp, index;
    while (i--) {
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(0, size);
}

function printResponses(responsesContainer) {
    var responses=JSON.parse(responsesContainer.dataset.responses);
    var stringResponses='<B>IMPORTANT!</B>To preserve this answer sequence for submission, when you have finalized your answers: <ol> <li> Copy the text in this cell below "Answer String"</li> <li> Double click on the cell directly below the Answer String, labeled "Replace Me"</li> <li> Select the whole "Replace Me" text</li> <li> Paste in your answer string and press shift-Enter.</li><li>Save the notebook using the save icon or File->Save Notebook menu item</li></ul><br><br><br><b>Answer String:</b><br> ';
    console.log(responses);
    responses.forEach((response, index) => {
        if (response) {
            console.log(index + ': ' + response);
            stringResponses+= index + ': ' + response +"<BR>";
        }
    });
    responsesContainer.innerHTML=stringResponses;
}
/* Callback function to determine whether a selected multiple-choice
   button corresponded to a correct answer and to provide feedback
   based on the answer */
function check_mc() {
    var id = this.id.split('-')[0];
    //var response = this.id.split('-')[1];
    //console.log(response);
    //console.log("In check_mc(), id="+id);
    //console.log(event.srcElement.id)           
    //console.log(event.srcElement.dataset.correct)   
    //console.log(event.srcElement.dataset.feedback)

    var label = event.srcElement;
    //console.log(label, label.nodeName);
    var depth = 0;
    while ((label.nodeName != "LABEL") && (depth < 20)) {
        label = label.parentElement;
        console.log(depth, label);
        depth++;
    }



    var answers = label.parentElement.children;
    //console.log(answers);

    // Split behavior based on multiple choice vs many choice:
    var fb = document.getElementById("fb" + id);



    /* Multiple choice (1 answer). Allow for 0 correct
       answers as an edge case */
    if (fb.dataset.numcorrect <= 1) {
        // What follows is for the saved responses stuff
        var outerContainer = fb.parentElement.parentElement;
        var responsesContainer = document.getElementById("responses" + outerContainer.id);
        if (responsesContainer) {
            //console.log(responsesContainer);
            var response = label.firstChild.innerText;
            if (label.querySelector(".QuizCode")){
                response+= label.querySelector(".QuizCode").firstChild.innerText;
            }
            console.log(response);
            //console.log(document.getElementById("quizWrap"+id));
            var qnum = document.getElementById("quizWrap"+id).dataset.qnum;
            console.log("Question " + qnum);
            //console.log(id, ", got numcorrect=",fb.dataset.numcorrect);
            var responses=JSON.parse(responsesContainer.dataset.responses);
            console.log(responses);
            responses[qnum]= response;
            responsesContainer.setAttribute('data-responses', JSON.stringify(responses));
            printResponses(responsesContainer);
        }
        // End code to preserve responses

        for (var i = 0; i < answers.length; i++) {
            var child = answers[i];
            //console.log(child);
            child.className = "MCButton";
        }



        if (label.dataset.correct == "true") {
            // console.log("Correct action");
            if ("feedback" in label.dataset) {
                fb.innerHTML = jaxify(label.dataset.feedback);
            } else {
                fb.innerHTML = "Correct!";
            }
            label.classList.add("correctButton");

            fb.className = "Feedback";
            fb.classList.add("correct");

        } else {
            if ("feedback" in label.dataset) {
                fb.innerHTML = jaxify(label.dataset.feedback);
            } else {
                fb.innerHTML = "Incorrect -- try again.";
            }
            //console.log("Error action");
            label.classList.add("incorrectButton");
            fb.className = "Feedback";
            fb.classList.add("incorrect");
        }
    }
    else { /* Many choice (more than 1 correct answer) */
        var reset = false;
        var feedback;
         if (label.dataset.correct == "true") {
            if ("feedback" in label.dataset) {
                feedback = jaxify(label.dataset.feedback);
            } else {
                feedback = "Correct!";
            }
            if (label.dataset.answered <= 0) {
                if (fb.dataset.answeredcorrect < 0) {
                    fb.dataset.answeredcorrect = 1;
                    reset = true;
                } else {
                    fb.dataset.answeredcorrect++;
                }
                if (reset) {
                    for (var i = 0; i < answers.length; i++) {
                        var child = answers[i];
                        child.className = "MCButton";
                        child.dataset.answered = 0;
                    }
                }
                label.classList.add("correctButton");
                label.dataset.answered = 1;
                fb.className = "Feedback";
                fb.classList.add("correct");

            }
        } else {
            if ("feedback" in label.dataset) {
                feedback = jaxify(label.dataset.feedback);
            } else {
                feedback = "Incorrect -- try again.";
            }
            if (fb.dataset.answeredcorrect > 0) {
                fb.dataset.answeredcorrect = -1;
                reset = true;
            } else {
                fb.dataset.answeredcorrect--;
            }

            if (reset) {
                for (var i = 0; i < answers.length; i++) {
                    var child = answers[i];
                    child.className = "MCButton";
                    child.dataset.answered = 0;
                }
            }
            label.classList.add("incorrectButton");
            fb.className = "Feedback";
            fb.classList.add("incorrect");
        }
        // What follows is for the saved responses stuff
        var outerContainer = fb.parentElement.parentElement;
        var responsesContainer = document.getElementById("responses" + outerContainer.id);
        if (responsesContainer) {
            //console.log(responsesContainer);
            var response = label.firstChild.innerText;
            if (label.querySelector(".QuizCode")){
                response+= label.querySelector(".QuizCode").firstChild.innerText;
            }
            console.log(response);
            //console.log(document.getElementById("quizWrap"+id));
            var qnum = document.getElementById("quizWrap"+id).dataset.qnum;
            console.log("Question " + qnum);
            //console.log(id, ", got numcorrect=",fb.dataset.numcorrect);
            var responses=JSON.parse(responsesContainer.dataset.responses);
            if (label.dataset.correct == "true") {
                if (typeof(responses[qnum]) == "object"){
                    if (!responses[qnum].includes(response))
                        responses[qnum].push(response);
                } else{
                    responses[qnum]= [ response ];
                }
            } else {
                responses[qnum]= response;
            }
            console.log(responses);
            responsesContainer.setAttribute('data-responses', JSON.stringify(responses));
            printResponses(responsesContainer);
        }
        // End save responses stuff



        var numcorrect = fb.dataset.numcorrect;
        var answeredcorrect = fb.dataset.answeredcorrect;
        if (answeredcorrect >= 0) {
            fb.innerHTML = feedback + " [" + answeredcorrect + "/" + numcorrect + "]";
        } else {
            fb.innerHTML = feedback + " [" + 0 + "/" + numcorrect + "]";
        }


    }

    if (typeof MathJax != 'undefined') {
        var version = MathJax.version;
        console.log('MathJax version', version);
        if (version[0] == "2") {
            MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
        } else if (version[0] == "3") {
            MathJax.typeset([fb]);
        }
    } else {
        console.log('MathJax not detected');
    }

}


/* Function to produce the HTML buttons for a multiple choice/
   many choice question  and to update the CSS tags based on
   the question type */
function make_mc(qa, shuffle_answers, outerqDiv, qDiv, aDiv, id) {

    var shuffled;
    if (shuffle_answers == true) {
        //console.log(shuffle_answers+" read as true");
        shuffled = getRandomSubarray(qa.answers, qa.answers.length);
    } else {
        //console.log(shuffle_answers+" read as false");
        shuffled = qa.answers;
    }


    var num_correct = 0;

    shuffled.forEach((item, index, ans_array) => {
        //console.log(answer);

        // Make input element
        var inp = document.createElement("input");
        inp.type = "radio";
        inp.id = "quizo" + id + index;
        inp.style = "display:none;";
        aDiv.append(inp);

        //Make label for input element
        var lab = document.createElement("label");
        lab.className = "MCButton";
        lab.id = id + '-' + index;
        lab.onclick = check_mc;
        var aSpan = document.createElement('span');
        aSpan.classsName = "";
        //qDiv.id="quizQn"+id+index;
        if ("answer" in item) {
            aSpan.innerHTML = jaxify(item.answer);
            //aSpan.innerHTML=item.answer;
        }
        lab.append(aSpan);

        // Create div for code inside question
        var codeSpan;
        if ("code" in item) {
            codeSpan = document.createElement('span');
            codeSpan.id = "code" + id + index;
            codeSpan.className = "QuizCode";
            var codePre = document.createElement('pre');
            codeSpan.append(codePre);
            var codeCode = document.createElement('code');
            codePre.append(codeCode);
            codeCode.innerHTML = item.code;
            lab.append(codeSpan);
            //console.log(codeSpan);
        }

        //lab.textContent=item.answer;

        // Set the data attributes for the answer
        lab.setAttribute('data-correct', item.correct);
        if (item.correct) {
            num_correct++;
        }
        if ("feedback" in item) {
            lab.setAttribute('data-feedback', item.feedback);
        }
        lab.setAttribute('data-answered', 0);

        aDiv.append(lab);

    });

    if (num_correct > 1) {
        outerqDiv.className = "ManyChoiceQn";
    } else {
        outerqDiv.className = "MultipleChoiceQn";
    }

    return num_correct;

}
// Object-oriented wrapper for MC/MANY choice
class MCQuestion extends Question {
    constructor(qa, id, idx, opts, rootDiv) { super(qa, id, idx, opts, rootDiv); }
    render() {
        //console.log("options.shuffleAnswers " + this.options.shuffleAnswers);
        const numCorrect = make_mc(
            this.qa,
            this.options.shuffleAnswers,
            this.outerqDiv,
            this.qDiv,
            this.aDiv,
            this.id
        );
        if ('answer_cols' in this.qa) {
            this.aDiv.style.gridTemplateColumns =
                'repeat(' + this.qa.answer_cols + ', 1fr)';
        }
        this.fbDiv.dataset.numcorrect = numCorrect;
        this.wrapper.appendChild(this.fbDiv);
    }
}
Question.register('multiple_choice', MCQuestion);
Question.register('many_choice', MCQuestion);
function check_numeric(ths, event) {

    if (event.keyCode === 13) {
        ths.blur();

        var id = ths.id.split('-')[0];

        var submission = ths.value;
        if (submission.indexOf('/') != -1) {
            var sub_parts = submission.split('/');
            //console.log(sub_parts);
            submission = sub_parts[0] / sub_parts[1];
        }
        //console.log("Reader entered", submission);

        if ("precision" in ths.dataset) {
            var precision = ths.dataset.precision;
            submission = Number(Number(submission).toPrecision(precision));
        }


        //console.log("In check_numeric(), id="+id);
        //console.log(event.srcElement.id)           
        //console.log(event.srcElement.dataset.feedback)

        var fb = document.getElementById("fb" + id);
        fb.style.display = "none";
        fb.innerHTML = "Incorrect -- try again.";

        var answers = JSON.parse(ths.dataset.answers);
        //console.log(answers);

        var defaultFB = "Incorrect. Try again.";
        var correct;
        var done = false;
        answers.every(answer => {
            //console.log(answer.type);

            correct = false;
            // if (answer.type=="value"){
            if ('value' in answer) {
                var value;
                if ("precision" in ths.dataset) {
                    value = answer.value.toPrecision(ths.dataset.precision);
                } else {
                    value = answer.value;
                }
                if (submission == value) {
                    if ("feedback" in answer) {
                        fb.innerHTML = jaxify(answer.feedback);
                    } else {
                        fb.innerHTML = jaxify("Correct");
                    }
                    correct = answer.correct;
                    //console.log(answer.correct);
                    done = true;
                }

                // } else if (answer.type=="range") {
            } else if ('range' in answer) {
                console.log(answer.range);
                console.log(submission, submission >=answer.range[0], submission < answer.range[1])
                if ((submission >= answer.range[0]) && (submission < answer.range[1])) {
                    fb.innerHTML = jaxify(answer.feedback);
                    correct = answer.correct;
                    console.log(answer.correct);
                    done = true;
                }
            } else if (answer.type == "default") {
                if ("feedback" in answer) {
                    defaultFB = answer.feedback;
                } 
            }
            if (done) {
                return false; // Break out of loop if this has been marked correct
            } else {
                return true; // Keep looking for case that includes this as a correct answer
            }
        });
        console.log("done:", done);

        if ((!done) && (defaultFB != "")) {
            fb.innerHTML = jaxify(defaultFB);
            //console.log("Default feedback", defaultFB);
        }

        fb.style.display = "block";
        if (correct) {
            ths.className = "Input-text";
            ths.classList.add("correctButton");
            fb.className = "Feedback";
            fb.classList.add("correct");
        } else {
            ths.className = "Input-text";
            ths.classList.add("incorrectButton");
            fb.className = "Feedback";
            fb.classList.add("incorrect");
        }

        // What follows is for the saved responses stuff
        var outerContainer = fb.parentElement.parentElement;
        var responsesContainer = document.getElementById("responses" + outerContainer.id);
        if (responsesContainer) {
            console.log(submission);
            var qnum = document.getElementById("quizWrap"+id).dataset.qnum;
            //console.log("Question " + qnum);
            //console.log(id, ", got numcorrect=",fb.dataset.numcorrect);
            var responses=JSON.parse(responsesContainer.dataset.responses);
            console.log(responses);
            if (submission == ths.value){
                responses[qnum]= submission;
            } else {
                responses[qnum]= ths.value + "(" + submission +")";
            }
            responsesContainer.setAttribute('data-responses', JSON.stringify(responses));
            printResponses(responsesContainer);
        }
        // End code to preserve responses

        if (typeof MathJax != 'undefined') {
            var version = MathJax.version;
            console.log('MathJax version', version);
            if (version[0] == "2") {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
            } else if (version[0] == "3") {
                MathJax.typeset([fb]);
            }
        } else {
            console.log('MathJax not detected');
        }
        // After correct answer, if next JupyterQuiz question exists and has a text input, scroll by current question height
        if (correct) {
            // find the current question wrapper
            var wrapper = ths.closest('.Quiz');
            if (wrapper) {
                var nextWrapper = wrapper.nextElementSibling;
                if (nextWrapper && nextWrapper.classList.contains('Quiz')) {
                    var nextInput = nextWrapper.querySelector('input.Input-text');
                    if (nextInput) {
                        var height = wrapper.getBoundingClientRect().height;
                        console.log(height);
                        nextInput.focus();
                    }
                }
            }
        }
        return false;
    }

}
// Object-oriented wrapper for numeric questions
class NumericQuestion extends Question {
    constructor(qa, id, idx, opts, rootDiv) {
        super(qa, id, idx, opts, rootDiv);
    }
    render() {
        make_numeric(this.qa, this.outerqDiv, this.qDiv, this.aDiv, this.id);
        this.wrapper.appendChild(this.fbDiv);
    }
}
Question.register('numeric', NumericQuestion);

function isValid(el, charC) {
    //console.log("Input char: ", charC);
    if (charC == 46) {
        if (el.value.indexOf('.') === -1) {
            return true;
        } else if (el.value.indexOf('/') != -1) {
            var parts = el.value.split('/');
            if (parts[1].indexOf('.') === -1) {
                return true;
            }
        }
        else {
            return false;
        }
    } else if (charC == 47) {
        if (el.value.indexOf('/') === -1) {
            if ((el.value != "") && (el.value != ".")) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    } else if (charC == 45) {
        var edex = el.value.indexOf('e');
        if (edex == -1) {
            edex = el.value.indexOf('E');
        }

        if (el.value == "") {
            return true;
        } else if (edex == (el.value.length - 1)) { // If just after e or E
            return true;
        } else {
            return false;
        }
    } else if (charC == 101) { // "e"
        if ((el.value.indexOf('e') === -1) && (el.value.indexOf('E') === -1) && (el.value.indexOf('/') == -1)) {
            // Prev symbol must be digit or decimal point:
            if (el.value.slice(-1).search(/\d/) >= 0) {
                return true;
            } else if (el.value.slice(-1).search(/\./) >= 0) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    } else {
        if (charC > 31 && (charC < 48 || charC > 57))
            return false;
    }
    return true;
}

function numeric_keypress(evnt) {
    var charC = (evnt.which) ? evnt.which : evnt.keyCode;

    if (charC == 13) {
        check_numeric(this, evnt);
    } else {
        return isValid(this, charC);
    }
}





function make_numeric(qa, outerqDiv, qDiv, aDiv, id) {



    //console.log(answer);


    outerqDiv.className = "NumericQn";
    aDiv.style.display = 'block';

    var lab = document.createElement("label");
    lab.className = "InpLabel";
    lab.innerHTML = "Type numeric answer here:";
    aDiv.append(lab);

    var inp = document.createElement("input");
    inp.type = "text";
    //inp.id="input-"+id;
    inp.id = id + "-0";
    inp.className = "Input-text";
    inp.setAttribute('data-answers', JSON.stringify(qa.answers));
    if ("precision" in qa) {
        inp.setAttribute('data-precision', qa.precision);
    }
    aDiv.append(inp);
    //console.log(inp);

    //inp.addEventListener("keypress", check_numeric);
    //inp.addEventListener("keypress", numeric_keypress);
    /*
    inp.addEventListener("keypress", function(event) {
        return numeric_keypress(this, event);
    }
                        );
                        */
    //inp.onkeypress="return numeric_keypress(this, event)";
    inp.onkeypress = numeric_keypress;
    inp.onpaste = event => false;

    inp.addEventListener("focus", function (event) {
        this.value = "";
        return false;
    }
    );


}
// Override show_questions to use object-oriented Question API
function show_questions(json, container) {
    // Accept container element or element ID
    if (typeof container === 'string') {
        container = document.getElementById(container);
    }
    if (!container) {
        console.error('show_questions: invalid container', container);
        return;
    }

    const shuffleQuestions = container.dataset.shufflequestions === 'True';
    const shuffleAnswers = container.dataset.shuffleanswers === 'True';
    const preserveResponses = container.dataset.preserveresponses === 'true';
    const maxWidth = parseInt(container.dataset.maxwidth, 10) || 0;
    let numQuestions = parseInt(container.dataset.numquestions, 10) || json.length;
    if (numQuestions > json.length) numQuestions = json.length;

    let questions = json;
    if (shuffleQuestions || numQuestions < json.length) {
        questions = getRandomSubarray(json, numQuestions);
    }

    questions.forEach((qa, index) => {
        const id = makeid(8);
        const options = {
            shuffleAnswers: shuffleAnswers,
            preserveResponses: preserveResponses,
            maxWidth: maxWidth
        };
        Question.create(qa, id, index, options, container);
    });

    if (preserveResponses) {
        const respDiv = document.createElement('div');
        respDiv.id = 'responses' + container.id;
        respDiv.className = 'JCResponses';
        respDiv.dataset.responses = JSON.stringify([]);
        respDiv.innerHTML = '<b>Select your answers and then follow the directions that will appear here.</b>';
        container.appendChild(respDiv);
    }

    // Trigger MathJax typesetting if available
    if (typeof MathJax != 'undefined') {
        console.log("MathJax version", MathJax.version);
        var version = MathJax.version;
        setTimeout(function(){
            var version = MathJax.version;
            console.log('After sleep, MathJax version', version);
            if (version[0] == "2") {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
            } else if (version[0] == "3") {
                if (MathJax.hasOwnProperty('typeset') ) {
                    MathJax.typeset([container]);
                } else {
                    console.log('WARNING: Trying to force load MathJax 3');
                    window.MathJax = {
                        tex: {
                            inlineMath: [['$', '$'], ['\\(', '\\)']]
                        },
                        svg: {
                            fontCache: 'global'
                        }
                    };

                    (function () {
                        var script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js';
                        script.async = true;
                        document.head.appendChild(script);
                    })();
                }
            }
        }, 500);
if (typeof version == 'undefined') {
        } else
        {
            if (version[0] == "2") {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
            } else if (version[0] == "3") {
                if (MathJax.hasOwnProperty('typeset') ) {
                    MathJax.typeset([container]);
                } else {
                    console.log('WARNING: Trying to force load MathJax 3');
                    window.MathJax = {
                        tex: {
                            inlineMath: [['$', '$'], ['\\(', '\\)']]
                        },
                        svg: {
                            fontCache: 'global'
                        }
                    };

                    (function () {
                        var script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js';
                        script.async = true;
                        document.head.appendChild(script);
                    })();
                }
            } else {
                console.log("MathJax not found");
            }
        }
    }
    // if (typeof MathJax !== 'undefined') {
    //     const v = MathJax.version;
    //     if (v[0] === '2') {
    //         MathJax.Hub.Queue(['Typeset', MathJax.Hub]);
    //     } else if (v[0] === '3') {
    //         MathJax.typeset([container]);
    //     }
    // }

    // Prevent link clicks from bubbling up
    Array.from(container.getElementsByClassName('Link')).forEach(link => {
        link.addEventListener('click', e => e.stopPropagation());
    });
}
function levenshteinDistance(a, b) {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;

    const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));

    for (let i = 0; i <= a.length; i++) {
        matrix[0][i] = i;
    }

    for (let j = 0; j <= b.length; j++) {
        matrix[j][0] = j;
    }

    for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            matrix[j][i] = Math.min(
                matrix[j - 1][i] + 1, // Deletion
                matrix[j][i - 1] + 1, // Insertion
                matrix[j - 1][i - 1] + cost // Substitution
            );
        }
    }
    return matrix[b.length][a.length];
}
// Object-oriented wrapper for string input questions
class StringQuestion extends Question {
    constructor(qa, id, idx, opts, rootDiv) {
        super(qa, id, idx, opts, rootDiv);
    }
    render() {
        make_string(this.qa, this.outerqDiv, this.qDiv, this.aDiv, this.id);
        this.wrapper.appendChild(this.fbDiv);
    }
}
Question.register('string', StringQuestion);

function check_string(ths, event) {
    if (event.keyCode === 13) {
        ths.blur();

        var id = ths.id.split('-')[0];
        var submission = ths.value.trim();
        var fb = document.getElementById("fb" + id);
        fb.style.display = "none";
        fb.innerHTML = "Incorrect -- try again.";

        var answers = JSON.parse(ths.dataset.answers);
        var defaultFB = "Incorrect. Try again.";
        var correct;
        var done = false;

        // Handle default answer pattern: filter out and capture default feedback
        var filteredAnswers = [];
        answers.forEach(answer => {
            if (answer.type === "default") {
                defaultFB = answer.feedback;
            } else {
                filteredAnswers.push(answer);
            }
        });
        answers = filteredAnswers;

        answers.every(answer => {
            correct = false;

            let match = false;
            if (answer.match_case) {
                match = submission === answer.answer;
            } else {
                match = submission.toLowerCase() === answer.answer.toLowerCase();
            }
            console.log(submission);
            console.log(answer.answer);
            console.log(match);

            if (match) {
                if ("feedback" in answer) {
                    fb.innerHTML = jaxify(answer.feedback);
                } else {
                    fb.innerHTML = jaxify("Correct");
                }
                correct = answer.correct;
                done = true;
            } else if (answer.fuzzy_threshold) {
                var max_length = Math.max(submission.length, answer.answer.length);
                var ratio;
                if (answer.match_case) {
                    ratio = 1- (levenshteinDistance(submission, answer.answer) / max_length);
                } else {
                    ratio = 1- (levenshteinDistance(submission.toLowerCase(),
                                                    answer.answer.toLowerCase()) / max_length);
                }
                if (ratio >= answer.fuzzy_threshold) {
                    if ("feedback" in answer) {
                        fb.innerHTML = jaxify("(Fuzzy) " + answer.feedback);
                    } else {
                        fb.innerHTML = jaxify("Correct");
                    }
                    correct = answer.correct;
                    done = true;
                }

            }

            if (done) {
                return false;
            } else {
                return true;
            }
        });

        if ((!done) && (defaultFB != "")) {
            fb.innerHTML = jaxify(defaultFB);
        }

        fb.style.display = "block";
        if (correct) {
            ths.className = "Input-text";
            ths.classList.add("correctButton");
            fb.className = "Feedback";
            fb.classList.add("correct");
        } else {
            ths.className = "Input-text";
            ths.classList.add("incorrectButton");
            fb.className = "Feedback";
            fb.classList.add("incorrect");
        }

        var outerContainer = fb.parentElement.parentElement;
        var responsesContainer = document.getElementById("responses" + outerContainer.id);
        if (responsesContainer) {
            var qnum = document.getElementById("quizWrap" + id).dataset.qnum;
            var responses = JSON.parse(responsesContainer.dataset.responses);
            responses[qnum] = submission;
            responsesContainer.setAttribute('data-responses', JSON.stringify(responses));
            printResponses(responsesContainer);
        }

        if (typeof MathJax != 'undefined') {
            var version = MathJax.version;
            if (version[0] == "2") {
                MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
            } else if (version[0] == "3") {
                MathJax.typeset([fb]);
            }
        } else {
            console.log('MathJax not detected');
        }
        // After correct answer, if next JupyterQuiz question exists and has a text input, scroll by current question height
        if (correct) {
            var wrapper = ths.closest('.Quiz');
            if (wrapper) {
                var nextWrapper = wrapper.nextElementSibling;
                if (nextWrapper && nextWrapper.classList.contains('Quiz')) {
                    var nextInput = nextWrapper.querySelector('input.Input-text');
                    if (nextInput) {
                        var height = wrapper.getBoundingClientRect().height;
                        nextInput.focus();
                    }
                }
            }
        }
        return false;
    }
}

function string_keypress(evnt) {
    var charC = (evnt.which) ? evnt.which : evnt.keyCode;

    if (charC == 13) {
        check_string(this, evnt);
    } 
}


function make_string(qa, outerqDiv, qDiv, aDiv, id) {
    outerqDiv.className = "StringQn";
    aDiv.style.display = 'block';

    var lab = document.createElement("label");
    lab.className = "InpLabel";
    lab.innerHTML = "Type your answer here:";
    aDiv.append(lab);

    var inp = document.createElement("input");
    inp.type = "text";
    inp.id = id + "-0";
    inp.className = "Input-text";
    inp.setAttribute('data-answers', JSON.stringify(qa.answers));
    // Apply optional input width (approx. number of characters, in em units)
    if (qa.input_width != null) {
        inp.style['min-width'] = qa.input_width + 'em';
    }
    aDiv.append(inp);

    inp.onkeypress = string_keypress;
    inp.onpaste = event => false;

    inp.addEventListener("focus", function (event) {
        this.value = "";
        return false;
    });
}
/*
 * Handle asynchrony issues when re-running quizzes in Jupyter notebooks.
 * Ensures show_questions is called after the container div is in the DOM.
 */
function try_show() {
  if (document.getElementById("FUBDYjgPuwjl")) {
    show_questions(questionsFUBDYjgPuwjl, FUBDYjgPuwjl);
  } else {
    setTimeout(try_show, 200);
  }
};
// Invoke immediately
{
  try_show();
}
}

</script>
</div>
</div>
</div></section>
<section id="independence" class="slide level2">
<h2>Independence</h2>
<p>Two events <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are said to be <strong>independent</strong> if the occurrence of one does not affect the probability of the other.</p>
<div class="fragment">
<p>How does this relate to the multiplication rule?</p>
<ul>
<li class="fragment">If <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are independent, then the conditional probability <span class="math inline">\(\P(B | A)\)</span> is simply <span class="math inline">\(\P(B)\)</span>.
<ul>
<li class="fragment">Knowing that <span class="math inline">\(A\)</span> has occurred does not change the probability of <span class="math inline">\(B\)</span> occurring.</li>
</ul></li>
</ul>
</div>
<div class="fragment">
<p>This means that for independent events, the multiplication rule simplifies to:<br>
<span class="math display">\[\P(A \cap B) = \P(A) \cdot \P(B)\]</span></p>
</div>
<div class="fragment">
<p>Our coin flip example illustrates this nicely.</p>
<ul>
<li class="fragment">If we flip a fair coin twice, the outcome of the first flip does not affect the outcome of the second flip.</li>
<li class="fragment">Therefore, the two events (the first flip being heads and the second flip being heads) are independent.</li>
</ul>
<p>So the probability of both flips being heads is simply</p>
</div>
<div class="fragment">
<p><span class="math display">\[\P(H_1 \cap H_2) = \P(H_1) \cdot \P(H_2) = \frac{1}{2} \cdot \frac{1}{2} = \frac{1}{4}\]</span></p>
</div>
</section>
<section id="complicated-counting" class="slide level2">
<h2>Complicated counting</h2>
<p>Counting gets confusing and cumbersome quickly, especially when we have many events or outcomes.</p>
<p>Say that I want to know the probability of getting exactly one head when flipping a coin 5 times.</p>
<p>Let’s think about the case where the first flip is heads.</p>
<ul>
<li class="fragment">The probability of getting a head on the first flip is <span class="math inline">\(\frac{1}{2}\)</span>, and the probability of getting tails on the 4 other flips is also <span class="math inline">\(\frac{1}{2}\)</span> each.</li>
<li class="fragment">Because the flips are independent, we can multiply these probabilities together to get the probability of this specific sequence of flips: <span class="math display">\[\P(H_1 \cap T_2 \cap T_3 \ldots \cap T_{5}) = \frac{1}{2} \cdot \left(\frac{1}{2}\right)^4 = \frac{1}{2^{5}}\]</span></li>
</ul>
<div class="fragment">
<p>Are we done? As it stands, this is the probability of getting heads on the first flip and tails on all other flips.</p>
<ul>
<li class="fragment">But there are many other sequences that would also meet the conditions of getting “exactly one head”
<ul>
<li class="fragment">For example, we could have heads on the second flip and tails on all other flips, or heads on the third flip and tails on all other flips, and so on.</li>
</ul></li>
<li class="fragment">In fact, there are exactly 5 different sequences that would meet the conditions of getting exactly one head in 5 flips. So we need to multiply our previous result by the number of sequences that meet the conditions: <span class="math display">\[\P(\text{exactly one head in 5 flips}) = 5 \cdot \frac{1}{2^{5}} = \frac{5}{32} \approx .16\]</span></li>
</ul>
</div>
</section>
<section id="counting-outcomes" class="slide level2">
<h2>Counting Outcomes</h2>
<p>There are two common types of outcomes we want to count: <strong>permutations</strong> and <strong>combinations</strong>.</p>
<div class="fragment">
<p>A <strong>combination</strong> is a selection of items or events without regard to the order in which they occur. For example, the number of ways 1 out of 5 flips could be heads.</p>
<p>An important and intuitive way to think about combinations is that we are <strong>choosing</strong> an item from a set. In our example, we are choosing 1 flip to be heads out of 5 flips.</p>
<p><span class="math display">\[
\begin{align*}
\text{Flip 1 is heads} &amp;= \{1, 0, 0, 0, 0\} \\
\text{Flip 2 is heads} &amp;= \{0, 1, 0, 0, 0\} \\
\text{Flip 3 is heads} &amp;= \{0, 0, 1, 0, 0\} \\
\vdots \\
\text{Flip 5 is heads} &amp;= \{0, 0, 0, 0, 1\}
\end{align*}
\]</span></p>
<p>It is clear here that there are 5 possible “slots” where we can place a head.</p>
</div>
<div class="fragment">
<p>What if we want to know the number of ways to choose 2 flips to be heads out of 5 flips? Naturally the logic above still applies, and the 5 flips we counted above are still all valid placements for one of the two heads. Now we just need to consider the second head.</p>
</div>
<div class="fragment">
<p>Let’s take the first row from above, where the first flip is heads. Given that the first flip is heads, how many ways can we choose a second flip to also be heads? The second flip can be any of the remaining 4 flips, so there are 4 possible choices. <span class="math display">\[
\begin{align*}
\text{Flip 1 and 2 are heads} &amp;= \{1, 1, 0, 0, 0\} \\
\text{Flip 1 and 3 are heads} &amp;= \{1, 0, 1, 0, 0\} \\
\text{Flip 1 and 4 are heads} &amp;= \{1, 0, 0, 1, 0\} \\
\text{Flip 1 and 5 are heads} &amp;= \{1, 0, 0, 0, 1\}
\end{align*}
\]</span></p>
</div>
<div class="fragment">
<p>Now let’s consider the second row, where the second flip is heads. Given that the second flip is heads, how many ways can we choose a first flip to also be heads? The first flip can be any of the remaining 4 flips, so there are again 4 possible choices.</p>
<p><span class="math display">\[
\begin{align*}
\text{Flip 2 and 1 are heads} &amp;= \{1, 1, 0, 0, 0\} \\
\text{Flip 2 and 3 are heads} &amp;= \{0, 1, 1, 0, 0\} \\
\text{Flip 2 and 4 are heads} &amp;= \{0, 1, 0, 1, 0\} \\
\text{Flip 2 and 5 are heads} &amp;= \{0, 1, 0, 0, 1\}
\end{align*}
\]</span></p>
</div>
<div class="fragment">
<p>You would continue this process for the third, fourth, and fifth flips. So for each of the 5 flips, you can choose any of the remaining 4 flips to be heads.</p>
<p>This gives us a total of <span class="math inline">\(5 \cdot 4 = 20\)</span> ways to choose 2 flips to be heads out of 5 flips.</p>
</div>
<div class="fragment">
<p>But wait! We already counted the combination of flips 2 and 1 earlier (just in a different order – where flip 1 was heads first).</p>
</div>
<div class="fragment">
<p>This illustrates the key distinction between combinations and permutations. A <strong>permutation</strong> is an arrangement of items or events in a specific order.</p>
<ul>
<li class="fragment">Every possible combination of heads can be arranged in different ways, leading to different sequences of flips.</li>
<li class="fragment">If you are only interested in counting combinations, listing out all of the possible arrangements like we did above leads to double counting.</li>
</ul>
</div>
<div class="fragment">
<p>Counting all of the possible permutations of a sequence is straightforward. Using the logic above, you just assign “slots” in a sequence to each of the items you are arranging.</p>
</div>
<div class="fragment">
<p>Each time you allocate a slot, you have one fewer item to place in the remaining slots. So for a sequence of length <span class="math inline">\(n\)</span>, the number of permutations is: <span class="math display">\[
n! = n \cdot (n-1) \cdot (n-2) \cdots 2 \cdot 1
\]</span></p>
</div>
<div class="fragment">
<p>Now, if we want to count combinations instead of permutations, we start with the number of permutations and then discount to account for the fact that the order does not matter.</p>
<p>Namely, the number of combinations of <span class="math inline">\(k\)</span> items from a set of <span class="math inline">\(n\)</span> items is given by the formula: <span class="math display">\[
\binom{n}{k} = \frac{n!}{k! \cdot (n-k)!}
\]</span></p>
</div>
<div class="fragment">
<p>This formula:</p>
<ul>
<li class="fragment">counts <em>all</em> of the possible permutations of the sequence (<span class="math inline">\(n!\)</span>)</li>
<li class="fragment">divides by the number of ways to arrange the <span class="math inline">\(k\)</span> items that are selected (which is <span class="math inline">\(k!\)</span>)</li>
<li class="fragment">divides by the number of ways to arrange the remaining <span class="math inline">\(n-k\)</span> items (which is <span class="math inline">\((n-k)!\)</span>).</li>
</ul>
</div>
<div class="fragment">
<p>In our example, we have <span class="math inline">\(n = 5\)</span> (the number of flips) and <span class="math inline">\(k = 2\)</span> (the number of heads). So the number of combinations of 2 heads from 5 flips is: <span class="math display">\[
\binom{5}{2} = \frac{5!}{2! \cdot (5-2)!} = \frac{5!}{2! \cdot 3!} = \frac{5 \cdot 4 \cdot 3!}{2 \cdot 1 \cdot 3!} = \frac{5 \cdot 4}{2 \cdot 1} = 10
\]</span></p>
</div>
</section>
<section id="end-of-part-1" class="slide level2">
<h2>End of Part 1</h2>
<p>This concludes the first part of our lecture on probability. We have covered the basic concepts of probability, how to compute probabilities for single and multiple events, and the distinction between combinations and permutations. Next we will talk about probability functions, which allow us to concisely describe the probability of outcomes that have many possible values.</p>
</section>
<section id="probability-functions" class="slide level2">
<h2>Probability functions</h2>
<p>Thinking about probability in terms of counting outcomes is useful, and it is always a good idea to keep that intuition in mind if you ever get stuck.</p>
<div class="fragment">
<p>However, it is often more convenient to work with <strong>probability functions</strong>.</p>
<ul>
<li class="fragment">assigns a probability to each possible outcome. For example, if we have a fair coin, we can define a probability function <span class="math inline">\(f\)</span> as follows: <span class="math display">\[
f(x) = \begin{cases}
  \frac{1}{2} &amp; \text{if } x = 0 \text{ (heads)} \\
  \frac{1}{2} &amp; \text{if } x = 1 \text{ (tails)} \\
  0 &amp; \text{otherwise}
\end{cases}
\]</span> where <span class="math inline">\(x\)</span> is the outcome of the coin flip (0 for heads, 1 for tails).</li>
</ul>
</div>
<div class="fragment">
<div title="Functions map inputs to outputs">
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Functions map inputs to outputs</strong></p>
</div>
<div class="callout-content">
<p>Functions are just a “map” that tells you what output to expect for each input. A probability function is a special type of function that maps inputs to probabilities in the range <span class="math inline">\([0, 1]\)</span>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="fragment">
<p>This might seem a bit redundant because we’re just presenting the same information in a new format.</p>
<p>But probability functions are much more concise!</p>
</div>
<div class="fragment">
<p>For example, if we have a die with six sides, we can define a probability function <span class="math inline">\(f\)</span> as follows: <span class="math display">\[
f(x) = \begin{cases}
    \frac{1}{6} &amp; \text{if } x = 1, 2, 3, 4, 5, 6 \\
    0 &amp; \text{otherwise}
\end{cases}
\]</span></p>
</div>
<div class="fragment">
<p>But we can also use the same function to describe the probability of rolling a die with any number of sides. For example, if we have a die with <span class="math inline">\(k\)</span> sides, we can define a probability function <span class="math inline">\(f\)</span> as follows:</p>
<p><span class="math display">\[
f(x) = \begin{cases}
    \frac{1}{k} &amp; \text{if } x = 1, 2, \ldots, k \\
    0 &amp; \text{otherwise}
\end{cases}
\]</span> This is much more concise than writing out the probability for each possible outcome, and it allows us to easily generalize to any number of sides.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource {python} number-lines code-with-copy"><code class="sourceCode"><span id="cb1-1"><a></a></span>
<span id="cb1-2"><a></a># Define your function below</span>
<span id="cb1-3"><a></a>def f(x, k):</span>
<span id="cb1-4"><a></a>    # your code here</span>
<span id="cb1-5"><a></a>    pass</span>
<span id="cb1-6"><a></a></span>
<span id="cb1-7"><a></a># Example usage:</span>
<span id="cb1-8"><a></a># print(f(1, 5))  # Expected output: 0.2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="fragment">
<p>Solution:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource {python} number-lines code-with-copy"><code class="sourceCode"><span id="cb2-1"><a></a></span>
<span id="cb2-2"><a></a>def f(x, k):</span>
<span id="cb2-3"><a></a>    if 1 &lt;= x &lt;= k:</span>
<span id="cb2-4"><a></a>        return 1 / k</span>
<span id="cb2-5"><a></a>    else:</span>
<span id="cb2-6"><a></a>        return 0</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="random-variables" class="slide level2">
<h2>Random Variables</h2>
<p>A random variable is a quantity that</p>
<ul>
<li class="fragment">can take on different values based on the outcome of a random event.</li>
<li class="fragment">it might be a discrete variable (like the outcome of a coin flip)</li>
<li class="fragment">it might be a continuous variable (like the height of a person).</li>
<li class="fragment">basically it is any quantity that has randomness associated with it.</li>
</ul>
<p>We denote random variables with capital letters, like <span class="math inline">\(X\)</span> or <span class="math inline">\(Y\)</span>. The specific values that a random variable can take on in a particular instance are usually denoted with lowercase letters, like <span class="math inline">\(x\)</span> or <span class="math inline">\(y\)</span>.</p>
</section>
<section id="probability-functions-for-random-variables" class="slide level2">
<h2>Probability Functions for Random Variables</h2>
<p>We use <strong>probability functions</strong> to describe the probabilities associated with random variables.</p>
<ul>
<li class="fragment">Specifically, a probability function <span class="math inline">\(f\)</span> for a random variable <span class="math inline">\(X\)</span> gives the probability that <span class="math inline">\(X\)</span> takes on a specific value <span class="math inline">\(x\)</span>.</li>
</ul>
<p>For example, let <span class="math inline">\(X\)</span> be a random variable that represents the outcome of flipping a fair coin. The probability function for <span class="math inline">\(X\)</span> would be: <span class="math display">\[
f(x) = \P (X = x) = \begin{cases}
    \frac{1}{2} &amp; \text{if } x = 0 \text{ (heads)} \\
    \frac{1}{2} &amp; \text{if } x = 1 \text{ (tails)} \\
    0 &amp; \text{otherwise}
\end{cases}
\]</span></p>
<div class="fragment">
<div title="Bernoulli random variable">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Bernoulli random variable</strong></p>
</div>
<div class="callout-content">
<p>The above is an example of a <strong>Bernoulli random variable</strong>, which takes on the value 1 with probability <span class="math inline">\(p\)</span> and the value 0 with probability <span class="math inline">\(1 - p\)</span>. In our case, <span class="math inline">\(p = \frac{1}{2}\)</span> for a fair coin.</p>
</div>
</div>
</div>
</div>
</div>
<div class="fragment">
<p>As mentioned above, we can also think about random variables with continuous values. For example, let <span class="math inline">\(Y\)</span> be a random variable that represents the height of a person in centimeters. Let’s assume that every person’s height is equally likely to be between 150 cm and 200 cm (this is not true of course). The probability function for <span class="math inline">\(Y\)</span> would be: <span class="math display">\[
f(y) = \P (Y = y) = \begin{cases}
    \frac{1}{50} &amp; \text{if } 150 \leq y \leq 200 \\
    0 &amp; \text{otherwise}
\end{cases}
\]</span></p>
</div>
<div class="fragment">
<div title="Uniform random variable">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Uniform random variable</strong></p>
</div>
<div class="callout-content">
<p>The above is an example of a <strong>uniform random variable</strong>, which takes on values in a continuous range with equal probability. In our case, the range is from 150 cm to 200 cm, and the probability density function is <span class="math inline">\(\frac{1}{50}\)</span>.</p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="random-variables-for-random-processes" class="slide level2">
<h2>Random Variables for random processes</h2>
<p>In statistics, we treat our data as a random variable (or a collection of random variables). What this means is that we assume that the data we observe is just one possible outcome of a random process.</p>
<p>This is a powerful assumption because it allows us to use probability theory to make inferences about the underlying process that generated the data. This is going to be a key idea in the next lecture and throughout the course.</p>
</section>
<section id="probability-distributions" class="slide level2">
<h2>Probability distributions</h2>
<p>We call the probability function for a random variable a <strong>probability distribution</strong></p>
<ul>
<li class="fragment">describes how the probabilities are distributed across the possible values of the random variable.</li>
</ul>
<div class="fragment">
<p>Distributions can be discrete or continuous, depending on the type of random variable.</p>
<ul>
<li class="fragment">for discrete random variables, the probability distribution is often represented as a <strong>probability mass function (PMF)</strong>, which gives the probability of each possible value.</li>
<li class="fragment">for continuous random variables, the probability distribution is represented as a <strong>probability density function (PDF)</strong>, which gives the density of probability at each point.</li>
</ul>
</div>
</section>
<section id="visualizing-random-variables-and-distributions" class="slide level2">
<h2>Visualizing Random Variables and Distributions</h2>
<p>Let’s say we have a random variable <span class="math inline">\(X\)</span>, but we don’t know the exact probability function. Instead, we have a set of observed data points <span class="math inline">\(\{x_1, x_2, \ldots, x_n\}\)</span> that we believe are individual realizations of <span class="math inline">\(X\)</span>. In other words, we have a sample of data that we think is representative of the underlying random variable.</p>
<p>How can we visualize this data to understand the distribution of <span class="math inline">\(X\)</span>? The simplest solution is to just plot how many times each value occurs in the data. We can use a <strong>bar chart</strong> to visualize the counts of each value.</p>
<div id="a44145c5" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb3-2"><a></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-3"><a></a></span>
<span id="cb3-4"><a></a>x <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb3-5"><a></a></span>
<span id="cb3-6"><a></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb3-7"><a></a>plt.hist(x, bins<span class="op">=</span>np.arange(<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">2.5</span>, <span class="dv">1</span>), density<span class="op">=</span><span class="va">False</span>, align<span class="op">=</span><span class="st">"mid"</span>, rwidth<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb3-8"><a></a>plt.xticks([<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb3-9"><a></a>plt.xlabel(<span class="st">'Value'</span>)</span>
<span id="cb3-10"><a></a>plt.ylabel(<span class="st">'Frequency'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>Text(0, 0.5, 'Frequency')</code></pre>
</div>

</div>
<img data-src="lecture-02-slides_files/figure-revealjs/cell-4-output-2.png" class="r-stretch"></section>
<section id="example-dice-rolls" class="slide level2">
<h2>Example: Dice Rolls</h2>
<p>Consider a bunch of dice rolls. If we roll a die 100 times, we would expect to see each number appear roughly a similar number of times.</p>
<p>If we plot the frequencies of each roll, we should see a discrete uniform distribution, where each number from 1 to 6 has approximately the same height. Let’s check it out:</p>
<div id="9cb54ef4" class="cell" data-execution_count="5">
<div class="cell-output cell-output-stdout">
<pre><code>Total number of dice rolls: 1000</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="5">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">rolls</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>3</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>3</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>6</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>5</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">9</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="fragment">
<p>Now the plot:</p>
<div id="12164adf" class="cell" data-execution_count="6">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture-02-slides_files/figure-revealjs/cell-7-output-1.png"></p>
</figure>
</div>
</div>
</div>
<p>Notice that when the <span class="math inline">\(y\)</span>-axis represents probabilities, the heights of the bars sum to 1. This is because the total probability of all possible outcomes must equal 1!</p>
</div>
</section>
<section id="histograms-for-continuous-random-variables" class="slide level2">
<h2>Histograms for Continuous Random Variables</h2>
<p>What about continuous random variables? In this case, we cannot just count the number of occurrences of each value, because there are infinitely many possible values.</p>
<div class="fragment">
<p>Instead, we can use a <strong>histogram</strong> to visualize the distribution of the data.</p>
</div>
<div class="fragment">
<p>The <strong>histogram</strong> is a graphical representation that summarizes the distribution of a dataset.</p>
<ul>
<li class="fragment">divides the data into discrete, equally-sized intervals (or “bins”) along the x-axis and counts how many data points fall into each bin.</li>
<li class="fragment">the height of each bar represents the either the total count of data points in that bin <strong>or</strong> the proportion of data points in that bin.</li>
<li class="fragment">if the height of the bar is the proportion, then the area of the bar represents the probability of the random variable falling within that bin.</li>
</ul>
</div>
<div class="fragment">
<p>The prices of Airbnb listings from back in the first lecture are a good example of a continuous random variable. The resolution (cents) is so small that basically every price is unique. So we cannot just count the number of occurrences of each price. Instead, we can create a histogram to visualize the distribution of prices across bins.</p>
<div id="afaccda7" class="cell" data-execution_count="7">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture-02-slides_files/figure-revealjs/cell-8-output-1.png"></p>
</figure>
</div>
</div>
</div>
<div title="Area under a probability distribution">
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Area under a probability distribution</strong></p>
</div>
<div class="callout-content">
<p>At the beginning of this lecture, we said that the probability of all possible outcomes must sum up to 1. This is true for both discrete and continuous random variables. For discrete random variables, the sum of the probabilities of all possible outcomes equals 1. For continuous random variables, the area under the probability density function (PDF) must equal 1.</p>
<p>For discrete: <span class="math display">\[ \sum_{x} f(x) = 1 \]</span> For continuous: <span class="math display">\[ \int_{-\infty}^{\infty} f(x) \, dx = 1 \]</span></p>
<p>We can use the same idea to compute the probability of a continuous random variable falling within a certain range. For example, if we want to know the probability that a continuous random variable <span class="math inline">\(X\)</span> falls between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, we can compute the area under the PDF from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span>: <span class="math display">\[ \P(a \leq X \leq b) = \int_{a}^{b} f(x) \, dx \]</span></p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="expectation" class="slide level2">
<h2>Expectation</h2>
<p>We are often interested in the <strong>average</strong> value of a random variable.</p>
<ul>
<li class="fragment">For example, if we play roulette, we might want to know the average amount of money we can expect to win or lose per game.</li>
</ul>
<div class="fragment">
<p>Why do we need an average?</p>
<ul>
<li class="fragment">Since a random variable can take on many different values, a single sample does not give you a lot of information.</li>
<li class="fragment">You might win hundreds of dollars on one game, but this does not mean you will win that much every time you play.</li>
</ul>
</div>
<div class="fragment">
<p>Instead, <strong>think about what would happen if we repeated the random process many times and took the average.</strong> - Values that occur more frequently will tend to have a larger impact on the average, while values that occur less frequently will have a smaller impact. - For example, at a casino roulette table perhaps you place a bet that has a 10% chance of winning. You might bet $1 and win $10 ($9 net profit) on one game, but if you lose $1 on the next 9 games you’re not making money in the long run. Even though $9 profit sounds great, the fact that it happens so infrequently (and you lose $1 90% of the time) means that your average profit is actually zero.</p>
</div>
<div class="fragment">
<div title="Gambling warning: the house always wins">
<div class="callout callout-warning callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Gambling warning: the house always wins</strong></p>
</div>
<div class="callout-content">
<p>Actually, at real casinos, the games are designed so that “the house always wins” in the long run. So they would not let you bet $10 to win $100 ($90 profit) with a 10% chance – they would give you worse odds, like a 9% chance of winning $100 for a $10 bet.</p>
<p>In the short term this is hardly noticeable – you’re actually quite likely to win a few times! But in the long term, the house edge means that you will lose money if you keep playing. This is why casinos are profitable businesses.</p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="expectation-formal-definition" class="slide level2">
<h2>Expectation (formal definition)</h2>
<p>We can formalize this idea that the average gives more weight to values that occur more frequently.</p>
<p>The <strong>expectation</strong> (or expected value) of a random variable <span class="math inline">\(X\)</span> is gives the average value of <span class="math inline">\(X\)</span> over many instances. It is denoted as <span class="math inline">\(\mathbb{E}[X]\)</span> or <span class="math inline">\(\mu_X\)</span>. The expectation is calculated as follows: <span class="math display">\[
\mathbb{E}[X] = \sum_{x} x \cdot f(x)
\]</span> where <span class="math inline">\(f(x)\)</span> is the probability function of <span class="math inline">\(X\)</span>. For continuous random variables, the sum is replaced with an integral: <span class="math display">\[
\mathbb{E}[X] = \int_{-\infty}^{\infty} x \cdot f(x) \, dx
\]</span></p>
<div class="fragment">
<p>The way to think about this is that the expectation is a weighted average of all possible values of <span class="math inline">\(X\)</span>, where the weights are the probabilities of each value.</p>
</div>
<div class="fragment">
<p>So in our roulette example, you can either lose $1 (with 90% probability) or win $9 (with 10% probability). The expectation would be: <span class="math display">\[
\begin{align*}
\mathbb{E}[X] &amp;= \sum_{x \in \{-1, 10\}} x \cdot f(x) \\
&amp;= (-1) \cdot 0.9 + (10-1) \cdot 0.1 \\
&amp;= -0.9 + 0.9 \\
&amp;= 0
\end{align*}
\]</span></p>
</div>
<div class="fragment">
<p>This is also the same as what you get if you just take the average of the outcomes. Say we play roulette 10 times, and we win $10 on one game and lose $1 on the other 9 games. The average outcome is: <span class="math display">\[
\begin{align*}
\frac{1}{10} \left( -1 \cdot 9 + 9 \cdot 1 \right) &amp;= -1 \cdot 0.9 + 9 \cdot 0.1 \\
&amp;= -0.9 + 0.9 \\
&amp;= 0
\end{align*}
\]</span></p>
</div>
<div class="fragment">
<p>So for a finite dataset, or set of outcomes, we can estimate the expected value by taking the average of the outcomes. This is often written as <span class="math inline">\(\bar{X}\)</span>, and referred to as the sample mean. <span class="math display">\[
\mathbb{E}[X] \approx \bar{X} = \frac{1}{n} \sum_{i=1}^{n} x_i
\]</span></p>
<p>This approximation becomes more accurate as the number of samples <span class="math inline">\(n\)</span> increases. We will talk about this more in a future lecture.</p>
</div>
</section>
<section id="variance-and-standard-deviation" class="slide level2">
<h2>Variance and standard deviation</h2>
<p>The average is a useful summary of a random variable’s central tendency, but it does not tell us anything about how spread out the values are.</p>
<div class="fragment">
<p>Consider the roulette example again. If we play roulette many times, it does not matter how much we bet on each game – the <strong>average</strong> amount we can expect to win or lose is always zero. You can bet $1 or $10,000 on each game, but the average outcome is still zero.</p>
</div>
<div class="fragment">
<p>Of course, the outcome of each game is not zero. Sometimes you win, sometimes you lose, and the amount you win or lose changes drastically depending on how much you bet.</p>
<div id="69ab7544" class="cell" data-execution_count="8">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture-02-slides_files/figure-revealjs/cell-9-output-1.png"></p>
</figure>
</div>
</div>
</div>
</div>
</section>
<section id="variance-intuition" class="slide level2">
<h2>Variance (intuition)</h2>
<p>How can we quantify this spread?</p>
<ul>
<li class="fragment">we want to capture that even though the average outcome is zero, winning $90 and losing $10 is very different from winning $9 and losing $1.
<ul>
<li class="fragment">maybe you want to pay for dinner with your winnings, so a $90 payout is much more useful than a $9 payout.</li>
<li class="fragment">maybe you only have $10 in your pocket, so you can’t afford to lose all of it on a single game.</li>
</ul></li>
</ul>
<div class="fragment">
<p>We need a statistic that captures the typical <em>distance</em> between the values of the random variable and the average value.</p>
</div>
<div class="fragment">
<div title="Why distance from the average?">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Why distance from the average?</strong></p>
</div>
<div class="callout-content">
<p>Let’s imagine for a moment that there was a casino (a very poorly run casino) that let you place bets that win no matter what – the only question is how much you win. Let’s take an example where the payouts still differ by $10: you get $5 if you “lose” and $15 if you “win”.</p>
<p>In this case, the expected value is: <span class="math display">\[
\mathbb{E}[X] = \sum_{x
} x \cdot f(x) = 5 \cdot 0.9 + 15 \cdot 0.1 = 4.5 + 1.5 = 6
\]</span> So you can expect to win $6 per game on average.</p>
<p>The amount that the winnings vary, though is exactly the same as the original roulette game. How can we replicate this notion mathematically?</p>
<p>The answer is simple: we subtract the average from each value of <span class="math inline">\(X\)</span>: <span class="math display">\[X' = X - \mathbb{E}[X]\]</span> This gives us a new random variable <span class="math inline">\(X'\)</span> that represents the distance from the average. Notice that this new random variable has an average of zero, just like the original roulette game.</p>
<p><span class="math display">\[\mathbb{E}[X'] = \sum_{x} (x - \mathbb{E}[X]) \cdot f(x) = ((5-6) \cdot 0.9 + (15-6) \cdot 0.1 = (-1) \cdot 0.9 + (9) \cdot 0.1 = -0.9 + 0.9 = 0\]</span></p>
<p>or more generally: <span class="math display">\[\mathbb{E}[X'] = \mathbb{E}[X - \mathbb{E}[X]] = \mathbb{E}[X] - \mathbb{E}[X] = 0\]</span></p>
</div>
</div>
</div>
</div>
</div>
<div class="fragment">
<p>So let’s compute exactly that - the distance from the average. The formula for distance between two vectors <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> is: <span class="math display">\[
d^2 = \sum_{i} (x_i - y_i)^2
\]</span> where <span class="math inline">\(x_i\)</span> and <span class="math inline">\(y_i\)</span> are the elements of the two vectors.</p>
<ul>
<li class="fragment">This is like the Pythagorean Theorem for computing the length of athe hypotenuse of a triange (<span class="math inline">\(a^2 + b^2 = c^2\)</span>).</li>
</ul>
</div>
<div class="fragment">
<p>In our case, we want to compute the distance between the values of the random variable <span class="math inline">\(X\)</span> and the average value <span class="math inline">\(\mathbb{E}[X]\)</span>. <span class="math display">\[
d^2 = \sqrt{\sum_x (x - \mathbb{E}[X])^2}
\]</span></p>
<p>Now we’re getting somewhere! However, this is adding up all of the squared distances – that means that the more values we have, the larger the distance will be.</p>
<p>This is not quite right – instead we want to compute the average distance from the mean in order to get a sense of how spread out the values <em>typically</em> are.</p>
</div>
<div class="fragment">
<p>So we need to divide by the number of values: <span class="math display">\[
d^2_\text{avg} = \frac{1}{n} \sum_x (x - \mathbb{E}[X])^2
\]</span></p>
<p>Something should feel familiar about this expression. Recall that the average is related to the expectation.</p>
</div>
<div class="fragment">
<p>If we replace the average with the expectation, we get the formula for the <strong>variance</strong> of a random variable <span class="math inline">\(X\)</span>: <span class="math display">\[
\text{Var}(X) = \sigma^2(X) = \mathbb{E}[(X - \mathbb{E}[X])^2] = \sum_x (x - \mathbb{E}[X])^2 \cdot f(x)
\]</span></p>
</div>
<div class="fragment">
<p>The variance tells us how spread out the values of a random variable are around the average.</p>
<ul>
<li class="fragment">a larger variance means that the values are more spread out</li>
<li class="fragment">a smaller variance means that the values are closer to the average.</li>
</ul>
</div>
<div class="fragment">
<p>The variance is a useful statistic, but it is not in the same units as the original random variable. For example, if <span class="math inline">\(X\)</span> represents the amount of money you win or lose in dollars, then the variance is in dollars squared. This can make it difficult to interpret.</p>
</div>
<div class="fragment">
<p>So we often take the square root of the variance to get the <strong>standard deviation</strong>: <span class="math display">\[
\text{SD}(X) = \sigma(X) = \sqrt{\text{Var}(X)} = \sqrt{\mathbb{E}[(X - \mathbb{E}[X])^2]}
\]</span></p>
</div>
<div class="fragment">
<p>Like with expected value, we can replace the expectation with the sample mean to get an estimate of the standard deviation (or variance) from a finite dataset: <span class="math display">\[
\hat{\sigma}(X) = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{X})^2}
\]</span></p>
</div>
<div class="fragment">
<div title="Sample variance vs. population variance">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Sample variance vs.&nbsp;population variance</strong></p>
</div>
<div class="callout-content">
<p>Technically, the formula above is an imperfect estimate of the population standard deviation. It’s in general a little bit too small, because the sample mean <span class="math inline">\(\bar{X}\)</span> does not perfectly represent the population mean <span class="math inline">\(\mathbb{E}[X]\)</span>. We can correct for this by dividing by <span class="math inline">\(n-1\)</span> instead of <span class="math inline">\(n\)</span>: <span class="math display">\[
\hat{\sigma}(X) = \sqrt{\frac{1}{n-1} \sum_{i=1}^{n} (x_i - \bar{X})^2}
\]</span> This is called the <strong>sample standard deviation</strong>.</p>
<p>Why is the initial estimate too small? In a small dataset, the sample mean “overfits” the data, meaning it is closer to the individual data points than the true population mean. Let’s think about this in terms of coin flips. If we flip a coin once, the sample mean is either <span class="math inline">\(\hat{X}=0\)</span> or 1, depending on whether we got heads or tails. But the true population mean is <span class="math inline">\(\mathbb{E}[X]=\frac{1}{2}\)</span>. If we compute the standard deviation using the original formula, the distance from the sample mean is exactly 0! So the standard deviation is also 0 (either <span class="math inline">\((1-1)^2\)</span> or <span class="math inline">\((0-0)^2\)</span>).</p>
<p>By contrast, the true (population) standard deviation is <span class="math inline">\(\sigma(X) = \sqrt{\mathbb{E}[(X - \mathbb{E}[X])^2]} = \sqrt{\frac{1}{4}} = \frac{1}{2}\)</span>, which is larger than the estimate using the sample mean.</p>
<p>This <strong>bias</strong> in computing the standard deviation gets smaller as the sample size <span class="math inline">\(n\)</span> increases, so for large datasets the difference is negligible. In smaller datasets, though, it is important to use the <span class="math inline">\(n-1\)</span> correction to get a more accurate estimate of the population standard deviation.</p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="common-probability-distributions" class="slide level2">
<h2>Common probability distributions</h2>
<p>Certain probability distributions are very common, and their corresponding probability functions are well-known. It is not necessary to memorize these distributions, but it is useful to be familiar with them and their properties.</p>
<!-- Table of common probability distributions: -->
<table class="caption-top">
<colgroup>
<col style="width: 20%">
<col style="width: 8%">
<col style="width: 31%">
<col style="width: 17%">
<col style="width: 8%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>Distribution</th>
<th>Type</th>
<th>Probability Function</th>
<th>Parameters</th>
<th>Mean</th>
<th>Variance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bernoulli</td>
<td>Discrete</td>
<td><span class="math inline">\(f(x) = p^x (1-p)^{1-x}\)</span></td>
<td><span class="math inline">\(p \in [0, 1]\)</span></td>
<td><span class="math inline">\(p\)</span></td>
<td><span class="math inline">\(p(1-p)\)</span></td>
</tr>
<tr class="even">
<td>Binomial</td>
<td>Discrete</td>
<td><span class="math inline">\(f(x) = \binom{n}{x} p^x (1-p)^{n-x}\)</span></td>
<td><span class="math inline">\(n \in \mathbb{N}, p \in [0, 1]\)</span></td>
<td><span class="math inline">\(np\)</span></td>
<td><span class="math inline">\(np(1-p)\)</span></td>
</tr>
<tr class="odd">
<td>Poisson</td>
<td>Discrete</td>
<td><span class="math inline">\(f(x) = \frac{\lambda^x e^{-\lambda}}{x!}\)</span></td>
<td><span class="math inline">\(\lambda &gt; 0\)</span></td>
<td><span class="math inline">\(\lambda\)</span></td>
<td><span class="math inline">\(\lambda\)</span></td>
</tr>
<tr class="even">
<td>Uniform</td>
<td>Continuous</td>
<td><span class="math inline">\(f(x) = \frac{1}{b-a}\)</span></td>
<td><span class="math inline">\(a &lt; b\)</span></td>
<td><span class="math inline">\(\frac{a+b}{2}\)</span></td>
<td><span class="math inline">\(\frac{(b-a)^2}{12}\)</span></td>
</tr>
<tr class="odd">
<td>Normal</td>
<td>Continuous</td>
<td><span class="math inline">\(f(x) = \frac{1}{\sqrt{2\pi\sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</span></td>
<td><span class="math inline">\(\mu \in \mathbb{R}, \sigma &gt; 0\)</span></td>
<td><span class="math inline">\(\mu\)</span></td>
<td><span class="math inline">\(\sigma^2\)</span></td>
</tr>
<tr class="even">
<td>Exponential</td>
<td>Continuous</td>
<td><span class="math inline">\(f(x) = \lambda e^{-\lambda x}\)</span></td>
<td><span class="math inline">\(\lambda &gt; 0\)</span></td>
<td><span class="math inline">\(\frac{1}{\lambda}\)</span></td>
<td><span class="math inline">\(\frac{1}{\lambda^2}\)</span></td>
</tr>
</tbody>
</table>
<p>The plots below show the probability functions for each of these distributions.</p>

<img data-src="lecture-02-slides_files/figure-revealjs/cell-10-output-1.png" class="r-stretch"></section>
<section id="summary" class="slide level2">
<h2>Summary</h2>
<p>This lecture introduced many important concepts from probability theory that will be useful throughout the course. Probability gives us a mathematical language and toolkit for reasoning about uncertainty and randomness in data, by thinking about possible outcomes and their likelihoods.</p>
<p>In particular, we covered:</p>
<ul>
<li class="fragment">The basic definition of probability and how to compute it for simple events.</li>
<li class="fragment">The addition and multiplication rules for calculating probabilities of multiple events.</li>
<li class="fragment">The concept of independence and how it affects probabilities.</li>
<li class="fragment">Random variables and their probability distributions</li>
<li class="fragment">The expectation (or expected value) of a random variable</li>
<li class="fragment">Variance and standard deviation</li>
</ul>
<div class="fragment">
<p>Going forward, these concepts will be foundational for statistical modeling and designing good simulations and statistical tests.</p>
<p>Assignment 2 will give you a chance to work through some of these concepts in more detail, so be sure to check it out!</p>


</div>
</section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<div class="footer footer-default">

</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../site_libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../site_libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-chalkboard/plugin.js"></script>
  <script src="../site_libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../site_libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../site_libs/revealjs/plugin/search/search.js"></script>
  <script src="../site_libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="../site_libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleChalkboard(event)\"><kbd>b</kbd> Toggle Chalkboard</a></li>\n<li class=\"slide-tool-item\" data-item=\"6\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleNotesCanvas(event)\"><kbd>c</kbd> Toggle Notes Canvas</a></li>\n<li class=\"slide-tool-item\" data-item=\"7\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.downloadDrawings(event)\"><kbd>d</kbd> Download Drawings</a></li>\n<li class=\"slide-tool-item\" data-item=\"8\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'chalkboard': {"buttons":true},
'smaller': true,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: false,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, RevealChalkboard, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
            const codeEl = trigger.previousElementSibling.cloneNode(true);
            for (const childEl of codeEl.children) {
              if (isCodeAnnotation(childEl)) {
                childEl.remove();
              }
            }
            return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp("https:\/\/jrudoler-teaching\.github\.io\/understanding-uncertainty\/");
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
            let selectedAnnoteEl;
            const selectorForAnnotation = ( cell, annotation) => {
              let cellAttr = 'data-code-cell="' + cell + '"';
              let lineAttr = 'data-code-annotation="' +  annotation + '"';
              const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
              return selector;
            }
            const selectCodeLines = (annoteEl) => {
              const doc = window.document;
              const targetCell = annoteEl.getAttribute("data-target-cell");
              const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
              const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
              const lines = annoteSpan.getAttribute("data-code-lines").split(",");
              const lineIds = lines.map((line) => {
                return targetCell + "-" + line;
              })
              let top = null;
              let height = null;
              let parent = null;
              if (lineIds.length > 0) {
                  //compute the position of the single el (top and bottom and make a div)
                  const el = window.document.getElementById(lineIds[0]);
                  top = el.offsetTop;
                  height = el.offsetHeight;
                  parent = el.parentElement.parentElement;
                if (lineIds.length > 1) {
                  const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
                  const bottom = lastEl.offsetTop + lastEl.offsetHeight;
                  height = bottom - top;
                }
                if (top !== null && height !== null && parent !== null) {
                  // cook up a div (if necessary) and position it 
                  let div = window.document.getElementById("code-annotation-line-highlight");
                  if (div === null) {
                    div = window.document.createElement("div");
                    div.setAttribute("id", "code-annotation-line-highlight");
                    div.style.position = 'absolute';
                    parent.appendChild(div);
                  }
                  div.style.top = top - 2 + "px";
                  div.style.height = height + 4 + "px";
                  div.style.left = 0;
                  let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
                  if (gutterDiv === null) {
                    gutterDiv = window.document.createElement("div");
                    gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                    gutterDiv.style.position = 'absolute';
                    const codeCell = window.document.getElementById(targetCell);
                    const gutter = codeCell.querySelector('.code-annotation-gutter');
                    gutter.appendChild(gutterDiv);
                  }
                  gutterDiv.style.top = top - 2 + "px";
                  gutterDiv.style.height = height + 4 + "px";
                }
                selectedAnnoteEl = annoteEl;
              }
            };
            const unselectCodeLines = () => {
              const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
              elementsIds.forEach((elId) => {
                const div = window.document.getElementById(elId);
                if (div) {
                  div.remove();
                }
              });
              selectedAnnoteEl = undefined;
            };
              // Handle positioning of the toggle
          window.addEventListener(
            "resize",
            throttle(() => {
              elRect = undefined;
              if (selectedAnnoteEl) {
                selectCodeLines(selectedAnnoteEl);
              }
            }, 10)
          );
          function throttle(fn, ms) {
          let throttle = false;
          let timer;
            return (...args) => {
              if(!throttle) { // first call gets through
                  fn.apply(this, args);
                  throttle = true;
              } else { // all the others get throttled
                  if(timer) clearTimeout(timer); // cancel #2
                  timer = setTimeout(() => {
                    fn.apply(this, args);
                    timer = throttle = false;
                  }, ms);
              }
            };
          }
            const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
            for (let i=0; i<annoteTargets.length; i++) {
              const annoteTarget = annoteTargets[i];
              const targetCell = annoteTarget.getAttribute("data-target-cell");
              const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
              const contentFn = () => {
                const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
                if (content) {
                  const tipContent = content.cloneNode(true);
                  tipContent.classList.add("code-annotation-tip-content");
                  return tipContent.outerHTML;
                }
              }
              const config = {
                allowHTML: true,
                content: contentFn,
                onShow: (instance) => {
                  selectCodeLines(instance.reference);
                  instance.reference.classList.add('code-annotation-active');
                  window.tippy.hideAll();
                },
                onHide: (instance) => {
                  unselectCodeLines();
                  instance.reference.classList.remove('code-annotation-active');
                },
                maxWidth: 300,
                delay: [50, 0],
                duration: [200, 0],
                offset: [5, 10],
                arrow: true,
                appendTo: function(el) {
                  return el.parentElement.parentElement.parentElement;
                },
                interactive: true,
                interactiveBorder: 10,
                theme: 'light-border',
                placement: 'right',
                popperOptions: {
                  modifiers: [
                  {
                    name: 'flip',
                    options: {
                      flipVariations: false, // true by default
                      allowedAutoPlacements: ['right'],
                      fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                    },
                  },
                  {
                    name: 'preventOverflow',
                    options: {
                      mainAxis: false,
                      altAxis: false
                    }
                  }
                  ]        
                }      
              };
              window.tippy(annoteTarget, config); 
            }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>